# Core Concepts

This page explains the foundational concepts behind RIPP™ and how they work together.

## Regenerative Intent

**Regenerative Intent** is the core principle of RIPP: intent must be preserved and regeneratable across the entire software lifecycle.

### What Is Intent?

Intent encompasses:

- **Why** the feature exists (problem being solved)
- **What** the feature does (solution and value delivered)
- **How** it works (data flows, UX patterns, API contracts)
- **Who** can use it (permissions and authorization)
- **What can go wrong** (failure modes and handling)
- **How to verify it** (acceptance tests)

### Why Intent Matters

Code is **ephemeral** and **environment-coupled**:

- Prototype code assumes single-user, trusted environments
- Production code assumes adversarial, multi-tenant, distributed environments
- Frameworks and languages change
- Architectures evolve (monolith → microservices → serverless)

Intent is **durable** and **portable**:

- The problem being solved remains constant
- The user value remains constant
- The data contracts (inputs/outputs) remain constant
- The UX patterns remain constant

**RIPP's role:** Capture intent so features can be regenerated when code needs to be rewritten.

---

## Intent vs Code

RIPP separates **intent** (what should happen) from **implementation** (how it's coded).

| Dimension           | Intent (RIPP)              | Code (Implementation)       |
| ------------------- | -------------------------- | --------------------------- |
| **Durability**      | Survives rewrites          | Gets rewritten              |
| **Reviewability**   | Reviewed before coding     | Reviewed during coding      |
| **Portability**     | Language/platform agnostic | Tied to tech stack          |
| **Validation**      | Schema-validated           | Syntax-validated            |
| **Evolution**       | Evolves with requirements  | Evolves with implementation |
| **Source of Truth** | RIPP packet                | Code must match RIPP        |

### Example

**Intent (RIPP):**

> Users must be authenticated with `editor` role to create items. Invalid SKUs return HTTP 400 with error details.

**Implementation (Code):**

```python
@app.route('/items', methods=['POST'])
@require_auth(['editor'])
def create_item():
    if not valid_sku(request.json['sku']):
        return jsonify({'error': 'Invalid SKU'}), 400
    # ...
```

**Key insight:** The RIPP packet defines the contract. The code implements it. If the implementation changes (Python → Go, monolith → microservices), the RIPP packet remains valid.

---

## Repo-Native Artifacts

RIPP packets are **repo-native**: they live in version control alongside code.

### What Repo-Native Means

- ✅ RIPP packets are stored in Git (or your VCS)
- ✅ They are versioned with the code they describe
- ✅ They follow the same review, approval, and merge workflow
- ✅ They can be diffed, branched, and merged like code
- ❌ They are NOT stored in external tools (Jira, Confluence, Notion)
- ❌ They are NOT generated documentation (like JSDoc or Swagger from code)

### Benefits of Repo-Native

| Benefit                    | Explanation                                     |
| -------------------------- | ----------------------------------------------- |
| **Single Source of Truth** | Spec and code are in the same repository        |
| **Diff-able**              | Changes to requirements are visible in PRs      |
| **Versioned Together**     | Code and spec versions stay in sync             |
| **Review-able**            | Specs are reviewed in the same workflow as code |
| **Accessible**             | No separate login or tool required              |

### Where RIPP Packets Live

**Recommended structure:**

```
your-repo/
├── ripp/
│   ├── features/
│   │   ├── user-authentication.ripp.yaml
│   │   ├── payment-processing.ripp.yaml
│   │   └── item-creation.ripp.yaml
│   └── README.md
├── src/
│   └── (your application code)
└── .github/
    └── workflows/
        └── ripp-validate.yml
```

**Alternative structures (also valid):**

- `/specs/` — Centralized specifications directory
- `/features/` — Alongside feature code
- `/docs/ripp/` — Under documentation directory

---

## Determinism vs Regeneration

RIPP embraces **deterministic specifications** with **regenerable implementations**.

### Deterministic Specifications

A RIPP packet is **deterministic**:

- Given the same RIPP packet, reviewers reach the same understanding
- Schema validation produces the same result every time
- Acceptance tests verify the same behavior
- No ambiguity in what the feature does

### Regenerable Implementations

Code is **regenerable** from RIPP:

- Can be rewritten in a different language
- Can be restructured (monolith → microservices)
- Can be generated by AI or written by humans
- Can be optimized without changing contracts

### Example: Regeneration in Practice

**Original Implementation (Prototype):**

- Python Flask, in-memory database, single-tenant
- No authentication, no error handling
- Works for demo

**Regenerated Implementation (Production):**

- Go microservices, PostgreSQL with replication, multi-tenant
- OAuth2 + RBAC, comprehensive error handling
- Production-ready

**Same RIPP Packet:**

The RIPP packet describing "Create Item" feature is identical. Only the implementation changed.

**Key insight:** Intent is preserved. Code is disposable.

---

## Why Validation Is Read-Only

RIPP validators **never modify source files**. This is a core design principle.

### Philosophy

- **Humans own intent** — Only humans can decide what a feature should do
- **Tools validate intent** — Tools check that specifications are correct and complete
- **No surprises** — Validation never changes your files

### What This Means

| Operation       | Read-Only? | Why?                                                                   |
| --------------- | ---------- | ---------------------------------------------------------------------- |
| `ripp validate` | ✅ Yes     | Only checks schema conformance                                         |
| `ripp lint`     | ✅ Yes     | Only reports best practice violations                                  |
| `ripp package`  | ✅ Yes     | Creates new file, never modifies source                                |
| `ripp analyze`  | ✅ Yes     | Creates new draft file, never edits existing                           |
| `ripp init`     | ⚠️ Writes  | But only creates new files, never modifies existing (unless `--force`) |

### Why Not Auto-Fix?

**Problem with auto-fix:**

- Validators don't understand intent
- Fixing structural issues != fixing semantic issues
- Auto-fixes can introduce subtle bugs
- Human review is bypassed

**RIPP's approach:**

1. Validator reports the issue
2. Human understands the root cause
3. Human fixes it deliberately
4. Validator confirms the fix

**Example:**

```
✗ my-feature.ripp.yaml
  • /purpose: must have required property 'problem'
```

**Bad auto-fix:** Add `problem: "TODO"` (syntactically valid, semantically useless)

**Good human fix:** Add `problem: "Users cannot manage items without manual database updates"`

---

## Scaffolding Is Always Explicit

RIPP never assumes you want to initialize a repository or create files automatically.

### Explicit Initialization

To set up RIPP in a repository:

```bash
ripp init
```

This is a **deliberate human action**. It does not happen:

- ❌ Automatically when installing `ripp-cli`
- ❌ Automatically when running `ripp validate`
- ❌ As a side effect of any other command

### Why Explicit Matters

- **Consent:** Humans decide when to adopt RIPP
- **Control:** Humans control where files are created
- **Clarity:** No hidden side effects or surprises

### What Gets Scaffolded

When you run `ripp init`, it creates:

- `ripp/` directory structure
- `ripp/README.md` documentation
- `.github/workflows/ripp-validate.yml` GitHub Action

**But only if they don't exist.** Existing files are never overwritten (unless `--force`).

---

## Humans Own Intent; Automation Executes It

RIPP's design philosophy is clear: **Humans define what should happen. Tools make it happen correctly.**

### Division of Responsibilities

| Responsibility                  | Owned By |
| ------------------------------- | -------- |
| Define feature purpose          | Human    |
| Specify data contracts          | Human    |
| Decide permissions model        | Human    |
| Document failure modes          | Human    |
| Write acceptance tests          | Human    |
| **Validate schema conformance** | **Tool** |
| **Check best practices**        | **Tool** |
| **Enforce CI/CD gates**         | **Tool** |
| **Package for handoff**         | **Tool** |

### What This Prevents

- ❌ AI "guessing" what a feature should do
- ❌ Tools inventing intent from incomplete data
- ❌ Auto-generated specs with placeholder TODOs
- ❌ Specifications that no human has reviewed

### What This Enables

- ✅ Reviewable specifications before coding
- ✅ Clear ownership of decisions
- ✅ Durable, intentional documentation
- ✅ Confidence that specs reflect actual intent

---

## Summary

| Concept                  | Core Principle                               |
| ------------------------ | -------------------------------------------- |
| **Regenerative Intent**  | Preserve the "why" and "how" across rewrites |
| **Intent vs Code**       | Intent is durable; code is ephemeral         |
| **Repo-Native**          | Specs live in Git alongside code             |
| **Determinism**          | Specifications are unambiguous               |
| **Read-Only Validation** | Tools never modify your files                |
| **Explicit Scaffolding** | Initialization requires human action         |
| **Human Ownership**      | Humans own intent; tools execute it          |

---

**Next Steps:**

- Read [RIPP Specification](RIPP-Specification) for protocol details
- See [Validation Rules](Validation-Rules) for what validation enforces
- Check [Design Philosophy](Design-Philosophy) for deeper rationale
