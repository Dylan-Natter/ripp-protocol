const yaml = require('js-yaml');

/**
 * RIPP Checklist Parser
 * Parses markdown checklist files generated by `ripp confirm --checklist`
 * and extracts checked candidates with their YAML content.
 *
 * Handles edge cases:
 * - Missing or empty files
 * - Malformed YAML blocks
 * - Partial/truncated blocks
 * - Windows line endings
 * - No items checked
 * - Duplicate entries
 */

/**
 * Parse a checklist markdown file and extract checked candidates
 *
 * @param {string} checklistContent - Raw markdown content
 * @returns {Object} - { candidates: Array, errors: Array, warnings: Array }
 */
function parseChecklist(checklistContent) {
  if (!checklistContent || checklistContent.trim().length === 0) {
    return {
      candidates: [],
      errors: ['Checklist file is empty'],
      warnings: []
    };
  }

  // Normalize line endings (handle Windows CRLF)
  const normalizedContent = checklistContent.replace(/\r\n/g, '\n');

  const candidates = [];
  const errors = [];
  const warnings = [];
  const seenSections = new Set(); // Track duplicates

  // Split by candidate sections (## Candidate N: section_name)
  const candidatePattern = /^## Candidate (\d+): (.+)$/gm;
  const matches = [...normalizedContent.matchAll(candidatePattern)];

  if (matches.length === 0) {
    errors.push('No candidate sections found in checklist');
    return { candidates, errors, warnings };
  }

  for (let i = 0; i < matches.length; i++) {
    const match = matches[i];
    const candidateNum = match[1];
    const section = match[2].trim();
    const startIndex = match.index;
    const endIndex = i < matches.length - 1 ? matches[i + 1].index : normalizedContent.length;

    // Extract the content between this candidate and the next
    const candidateBlock = normalizedContent.substring(startIndex, endIndex);

    // Check if this candidate is accepted (has [x] checkbox)
    const acceptPattern = /^- \[x\] Accept this candidate$/im;
    const isAccepted = acceptPattern.test(candidateBlock);

    if (!isAccepted) {
      continue; // Skip unchecked candidates
    }

    // Extract confidence (optional, for metadata)
    const confidenceMatch = candidateBlock.match(/\*\*Confidence\*\*: ([\d.]+)%/);
    const confidence = confidenceMatch ? parseFloat(confidenceMatch[1]) / 100 : 0.8;

    // Extract evidence count (optional, for metadata)
    const evidenceMatch = candidateBlock.match(/\*\*Evidence\*\*: (\d+) reference/);
    const evidenceCount = evidenceMatch ? parseInt(evidenceMatch[1], 10) : 0;

    // Extract YAML content from code block
    const yamlPattern = /```yaml\n([\s\S]*?)\n```/;
    const yamlMatch = candidateBlock.match(yamlPattern);

    if (!yamlMatch) {
      errors.push(`Candidate ${candidateNum} (${section}): No YAML content block found`);
      continue;
    }

    const yamlContent = yamlMatch[1];

    // Validate YAML can be parsed
    let parsedContent;
    try {
      parsedContent = yaml.load(yamlContent);
    } catch (yamlError) {
      errors.push(`Candidate ${candidateNum} (${section}): Invalid YAML - ${yamlError.message}`);
      continue;
    }

    // Check for duplicate sections
    if (seenSections.has(section)) {
      warnings.push(
        `Candidate ${candidateNum} (${section}): Duplicate section detected, using first occurrence`
      );
      continue;
    }

    seenSections.add(section);

    // Build candidate object
    candidates.push({
      candidateNum,
      section,
      confidence,
      evidenceCount,
      content: parsedContent,
      rawYaml: yamlContent
    });
  }

  return {
    candidates,
    errors,
    warnings
  };
}

/**
 * Convert parsed checklist candidates into confirmed intent format
 *
 * @param {Array} candidates - Parsed candidates from parseChecklist
 * @param {Object} metadata - Optional metadata (user, timestamp)
 * @returns {Object} - Confirmed intent data structure
 */
function buildConfirmedIntent(candidates, metadata = {}) {
  const confirmed = candidates.map(candidate => ({
    section: candidate.section,
    source: 'confirmed',
    confirmed_at: metadata.timestamp || new Date().toISOString(),
    confirmed_by: metadata.user || 'checklist',
    original_confidence: candidate.confidence,
    evidence: [], // Evidence references not preserved in checklist format
    content: candidate.content
  }));

  return {
    version: '1.0',
    confirmed
  };
}

/**
 * Validate confirmed intent blocks against quality rules
 *
 * @param {Array} confirmed - Array of confirmed intent blocks
 * @returns {Object} - { accepted: Array, rejected: Array, reasons: Object }
 */
function validateConfirmedBlocks(confirmed) {
  const accepted = [];
  const rejected = [];
  const reasons = {};

  for (const block of confirmed) {
    const blockErrors = [];
    const section = block.section;

    // Rule 1: Section must be a known RIPP section
    const knownSections = [
      'purpose',
      'ux_flow',
      'data_contracts',
      'api_contracts',
      'permissions',
      'failure_modes',
      'audit_events',
      'nfrs',
      'acceptance_tests',
      'design_philosophy',
      'design_decisions',
      'constraints',
      'success_criteria'
    ];

    if (!knownSections.includes(section)) {
      blockErrors.push(`Unknown section type: ${section}`);
    }

    // Rule 2: Content must not be empty
    if (!block.content || Object.keys(block.content).length === 0) {
      blockErrors.push('Content is empty');
    }

    // Rule 3: Check for placeholder values (based on linter rules)
    const contentStr = JSON.stringify(block.content).toLowerCase();
    const placeholders = ['unknown', 'todo', 'tbd', 'fixme', 'placeholder', 'xxx'];

    for (const placeholder of placeholders) {
      if (contentStr.includes(placeholder)) {
        blockErrors.push(`Contains placeholder value: ${placeholder}`);
        break; // Only report once per block
      }
    }

    // Rule 4: Confidence threshold (if available and low)
    if (block.original_confidence && block.original_confidence < 0.5) {
      blockErrors.push(`Low confidence: ${(block.original_confidence * 100).toFixed(1)}%`);
    }

    if (blockErrors.length > 0) {
      rejected.push(block);
      reasons[section] = blockErrors;
    } else {
      accepted.push(block);
    }
  }

  return {
    accepted,
    rejected,
    reasons
  };
}

module.exports = {
  parseChecklist,
  buildConfirmedIntent,
  validateConfirmedBlocks
};
